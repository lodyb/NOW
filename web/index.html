<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NOW Media Library</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }
    h1, h2, h3 {
      color: #2c3e50;
    }
    .container {
      background-color: white;
      border-radius: 5px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .card {
      margin-bottom: 20px;
      padding: 15px;
      border-radius: 5px;
      background-color: #f8f9fa;
      border-left: 4px solid #3498db;
    }
    a.button {
      display: inline-block;
      background-color: #3498db;
      color: white;
      text-decoration: none;
      padding: 10px 15px;
      border-radius: 4px;
      margin-top: 10px;
    }
    a.button:hover {
      background-color: #2980b9;
    }
    .command {
      background-color: #f1f1f1;
      padding: 5px 10px;
      border-radius: 3px;
      font-family: monospace;
      margin: 2px 0;
      display: inline-block;
    }
    
    /* Media Library Styles */
    .media-tools {
      margin-bottom: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .search-box {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      width: 300px;
      font-size: 16px;
    }
    .media-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    .media-count {
      font-size: 14px;
      color: #777;
      margin-top: 5px;
    }
    .media-item {
      background-color: #fff;
      border-radius: 5px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      overflow: hidden;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .media-item:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .media-thumbnail {
      height: 180px;
      background-color: #f0f0f0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .media-thumbnail img, .media-thumbnail video {
      max-width: 100%;
      max-height: 100%;
    }
    .media-details {
      padding: 15px;
    }
    .media-title {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 16px;
    }
    .media-info {
      font-size: 14px;
      color: #666;
      margin-bottom: 15px;
    }
    .media-actions {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }
    .media-btn {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    .delete-btn {
      background-color: #e74c3c;
    }
    .media-btn:hover {
      opacity: 0.9;
    }
    
    /* Edit modal styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      display: none;
    }
    .modal {
      background-color: white;
      border-radius: 5px;
      width: 600px;
      max-width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    .modal-header {
      padding: 15px 20px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .modal-close {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #999;
    }
    .modal-body {
      padding: 20px;
    }
    .modal-footer {
      padding: 15px 20px;
      border-top: 1px solid #eee;
      text-align: right;
    }
    .form-group {
      margin-bottom: 15px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    input[type="text"], textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
    }
    textarea {
      min-height: 120px;
      resize: vertical;
    }
    .save-btn {
      background-color: #2ecc71;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }
    .save-btn:hover {
      background-color: #27ae60;
    }
    
    /* Loading and status indicators */
    .loading {
      text-align: center;
      padding: 40px;
      color: #777;
    }
    .status-message {
      padding: 10px 15px;
      margin: 10px 0;
      border-radius: 4px;
      display: none;
    }
    .status-success {
      background-color: #d4edda;
      color: #155724;
    }
    .status-error {
      background-color: #f8d7da;
      color: #721c24;
    }
    
    /* Pagination */
    .pagination {
      display: flex;
      justify-content: center;
      margin-top: 30px;
    }
    .pagination button {
      background-color: #f0f0f0;
      border: none;
      color: #333;
      padding: 8px 15px;
      margin: 0 5px;
      border-radius: 4px;
      cursor: pointer;
    }
    .pagination button.active {
      background-color: #3498db;
      color: white;
    }
    .pagination button:hover:not(.active) {
      background-color: #ddd;
    }
    .pagination button:disabled {
      background-color: #f0f0f0;
      color: #999;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>NOW Media Library</h1>
      <div class="card">
        <h2>Media Management</h2>
        <p>Manage all the media files for your Discord bot's music quiz games.</p>
        <a href="/upload" class="button">Upload New Media</a>
      </div>
    </header>
    
    <div class="media-library">
      <h2>All Media Files</h2>
      <div class="media-tools">
        <input type="text" id="searchInput" class="search-box" placeholder="Search by title...">
        <div class="media-count" id="mediaCount">Loading...</div>
      </div>
      
      <div id="statusMessage" class="status-message"></div>
      
      <div id="mediaContainer">
        <div class="loading" id="loadingIndicator">
          <p>Loading media files...</p>
        </div>
        <div class="media-grid" id="mediaGrid"></div>
      </div>
      
      <div class="pagination" id="pagination"></div>
    </div>
  </div>
  
  <!-- Edit Modal -->
  <div class="modal-overlay" id="editModal">
    <div class="modal">
      <div class="modal-header">
        <h3>Edit Media</h3>
        <button class="modal-close" id="closeModal">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label for="editTitle">Title:</label>
          <input type="text" id="editTitle" placeholder="Enter title">
        </div>
        <div class="form-group">
          <label for="editAnswers">Alternative Answers (one per line):</label>
          <textarea id="editAnswers" placeholder="Enter alternative answers (one per line)"></textarea>
        </div>
      </div>
      <div class="modal-footer">
        <button class="save-btn" id="saveMediaBtn">Save Changes</button>
      </div>
    </div>
  </div>

  <script>
    // DOM Elements
    const searchInput = document.getElementById('searchInput');
    const mediaCount = document.getElementById('mediaCount');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const mediaGrid = document.getElementById('mediaGrid');
    const statusMessage = document.getElementById('statusMessage');
    const pagination = document.getElementById('pagination');
    
    // Edit Modal Elements
    const editModal = document.getElementById('editModal');
    const closeModal = document.getElementById('closeModal');
    const editTitle = document.getElementById('editTitle');
    const editAnswers = document.getElementById('editAnswers');
    const saveMediaBtn = document.getElementById('saveMediaBtn');
    
    // State
    let allMedia = [];
    let filteredMedia = [];
    let currentPage = 1;
    const itemsPerPage = 12;
    let currentEditId = null;
    
    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      fetchAllMedia();
      setupEventListeners();
    });
    
    // Event Listeners
    function setupEventListeners() {
      // Search
      searchInput.addEventListener('input', handleSearch);
      
      // Modal
      closeModal.addEventListener('click', closeEditModal);
      saveMediaBtn.addEventListener('click', saveMedia);
      
      // Close modal when clicking outside
      editModal.addEventListener('click', (e) => {
        if (e.target === editModal) {
          closeEditModal();
        }
      });
    }
    
    // Fetch all media from the API
    function fetchAllMedia() {
      loadingIndicator.style.display = 'block';
      mediaGrid.style.display = 'none';
      
      console.log('Fetching all media...');
      fetch('/api/media')
        .then(response => {
          console.log('API response status:', response.status);
          if (!response.ok) {
            throw new Error('Failed to fetch media');
          }
          return response.json();
        })
        .then(data => {
          console.log('API response data:', data);
          if (data.success && Array.isArray(data.media)) {
            allMedia = data.media;
            // Sort by creation date (newest first)
            allMedia.sort((a, b) => {
              if (a.createdAt && b.createdAt) {
                return new Date(b.createdAt) - new Date(a.createdAt);
              }
              return b.id - a.id;
            });
            
            filteredMedia = [...allMedia];
            mediaCount.textContent = `${allMedia.length} media files found`;
            renderMediaGrid();
          } else {
            throw new Error('Invalid API response format');
          }
        })
        .catch(error => {
          console.error('Error fetching media:', error);
          showStatus('Error loading media: ' + error.message, 'error');
          mediaCount.textContent = 'Error loading media files';
        })
        .finally(() => {
          loadingIndicator.style.display = 'none';
          mediaGrid.style.display = 'grid';
        });
    }
    
    // Render media grid with current filtered results
    function renderMediaGrid() {
      const startIndex = (currentPage - 1) * itemsPerPage;
      const endIndex = startIndex + itemsPerPage;
      const paginatedMedia = filteredMedia.slice(startIndex, endIndex);
      
      // Clear grid
      mediaGrid.innerHTML = '';
      
      if (paginatedMedia.length === 0) {
        mediaGrid.innerHTML = '<div class="loading">No media files found.</div>';
        pagination.innerHTML = '';
        return;
      }
      
      // Create media items
      paginatedMedia.forEach(media => {
        const mediaItem = createMediaItem(media);
        mediaGrid.appendChild(mediaItem);
      });
      
      // Update pagination
      renderPagination();
    }
    
    // Create a single media item element
    function createMediaItem(media) {
      const item = document.createElement('div');
      item.className = 'media-item';
      
      // Determine if video or audio
      const isVideo = media.normalizedPath && 
        media.normalizedPath.match(/\.(mp4|webm|mov)$/i);
      
      // Create thumbnail
      let thumbnailHtml = '';
      if (media.normalizedPath) {
        if (isVideo) {
          thumbnailHtml = `
            <video src="/media/${media.id}/preview" muted></video>
          `;
        } else {
          thumbnailHtml = `
            <img src="/media/${media.id}/waveform" alt="Audio waveform">
          `;
        }
      } else {
        thumbnailHtml = `
          <div style="font-size: 48px; color: #ccc;">
            ${isVideo ? 'ðŸŽ¬' : 'ðŸŽµ'}
          </div>
        `;
      }
      
      // Format creation date
      let dateStr = 'Unknown date';
      if (media.createdAt) {
        const date = new Date(media.createdAt);
        dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
      }
      
      // Get answer count
      const answerCount = media.answers ? media.answers.length : 0;
      
      item.innerHTML = `
        <div class="media-thumbnail">
          ${thumbnailHtml}
        </div>
        <div class="media-details">
          <div class="media-title">${media.title || 'Untitled'}</div>
          <div class="media-info">
            <div>ID: ${media.id}</div>
            <div>Added: ${dateStr}</div>
            <div>Answers: ${answerCount}</div>
          </div>
          <div class="media-actions">
            <button class="media-btn edit-btn" data-id="${media.id}">Edit</button>
            <button class="media-btn delete-btn" data-id="${media.id}">Delete</button>
          </div>
        </div>
      `;
      
      // Add event listeners for buttons
      item.querySelector('.edit-btn').addEventListener('click', () => {
        openEditModal(media);
      });
      
      item.querySelector('.delete-btn').addEventListener('click', () => {
        if (confirm(`Are you sure you want to delete "${media.title}"?`)) {
          deleteMedia(media.id);
        }
      });
      
      return item;
    }
    
    // Open edit modal
    function openEditModal(media) {
      currentEditId = media.id;
      
      // Populate form fields
      editTitle.value = media.title || '';
      
      // Get answers text (one per line)
      let answersText = '';
      if (media.answers && Array.isArray(media.answers)) {
        answersText = media.answers
          .filter(a => !a.isPrimary) // Filter out primary answers (these are the same as title)
          .map(a => a.answer)
          .join('\n');
      }
      editAnswers.value = answersText;
      
      // Show modal
      editModal.style.display = 'flex';
    }
    
    // Close edit modal
    function closeEditModal() {
      editModal.style.display = 'none';
      currentEditId = null;
    }
    
    // Save media changes
    function saveMedia() {
      if (!currentEditId) return;
      
      const title = editTitle.value.trim();
      const answersText = editAnswers.value.trim();
      
      // Split answers by newline and filter out empty lines
      const answers = answersText.split('\n').filter(a => a.trim() !== '');
      
      // Validate
      if (!title) {
        showStatus('Title cannot be empty', 'error');
        return;
      }
      
      saveMediaBtn.disabled = true;
      saveMediaBtn.textContent = 'Saving...';
      
      // Send PUT request
      fetch(`/api/media/${currentEditId}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          title,
          answers
        })
      })
      .then(response => {
        if (!response.ok) {
          throw new Error('Failed to update media');
        }
        return response.json();
      })
      .then(data => {
        showStatus('Media updated successfully', 'success');
        closeEditModal();
        
        // Update the media item in our local array
        const index = allMedia.findIndex(m => m.id === currentEditId);
        if (index !== -1) {
          allMedia[index] = data.media;
          renderMediaGrid();
        }
      })
      .catch(error => {
        console.error('Error updating media:', error);
        showStatus('Error updating media: ' + error.message, 'error');
      })
      .finally(() => {
        saveMediaBtn.disabled = false;
        saveMediaBtn.textContent = 'Save Changes';
      });
    }
    
    // Delete media
    function deleteMedia(id) {
      fetch(`/api/media/${id}`, {
        method: 'DELETE'
      })
      .then(response => {
        if (!response.ok) {
          throw new Error('Failed to delete media');
        }
        return response.json();
      })
      .then(data => {
        showStatus('Media deleted successfully', 'success');
        
        // Remove from arrays
        allMedia = allMedia.filter(m => m.id !== id);
        filteredMedia = filteredMedia.filter(m => m.id !== id);
        
        // Update count
        mediaCount.textContent = `${allMedia.length} media files found`;
        
        // Re-render
        renderMediaGrid();
      })
      .catch(error => {
        console.error('Error deleting media:', error);
        showStatus('Error deleting media: ' + error.message, 'error');
      });
    }
    
    // Handle search input
    function handleSearch() {
      const searchTerm = searchInput.value.trim().toLowerCase();
      
      if (searchTerm === '') {
        filteredMedia = [...allMedia];
      } else {
        filteredMedia = allMedia.filter(media => {
          // Search in title
          if (media.title && media.title.toLowerCase().includes(searchTerm)) {
            return true;
          }
          
          // Search in answers
          if (media.answers && Array.isArray(media.answers)) {
            return media.answers.some(a => 
              a.answer && a.answer.toLowerCase().includes(searchTerm)
            );
          }
          
          return false;
        });
      }
      
      // Reset to first page and update display
      currentPage = 1;
      mediaCount.textContent = `${filteredMedia.length} media files found`;
      renderMediaGrid();
    }
    
    // Render pagination controls
    function renderPagination() {
      const pageCount = Math.ceil(filteredMedia.length / itemsPerPage);
      
      if (pageCount <= 1) {
        pagination.innerHTML = '';
        return;
      }
      
      // Create pagination
      let paginationHtml = '';
      
      // Previous button
      paginationHtml += `
        <button ${currentPage === 1 ? 'disabled' : ''} data-page="prev">
          &laquo; Previous
        </button>
      `;
      
      // Page buttons (max 5 pages shown)
      const maxVisiblePages = 5;
      let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
      let endPage = Math.min(pageCount, startPage + maxVisiblePages - 1);
      
      // Adjust if we're near the end
      if (endPage - startPage + 1 < maxVisiblePages && startPage > 1) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1);
      }
      
      for (let i = startPage; i <= endPage; i++) {
        paginationHtml += `
          <button class="${i === currentPage ? 'active' : ''}" data-page="${i}">
            ${i}
          </button>
        `;
      }
      
      // Next button
      paginationHtml += `
        <button ${currentPage === pageCount ? 'disabled' : ''} data-page="next">
          Next &raquo;
        </button>
      `;
      
      pagination.innerHTML = paginationHtml;
      
      // Add event listeners to pagination buttons
      const buttons = pagination.querySelectorAll('button');
      buttons.forEach(button => {
        button.addEventListener('click', handlePagination);
      });
    }
    
    // Handle pagination clicks
    function handlePagination(e) {
      const pageCount = Math.ceil(filteredMedia.length / itemsPerPage);
      const page = e.target.dataset.page;
      
      if (page === 'prev') {
        currentPage = Math.max(1, currentPage - 1);
      } else if (page === 'next') {
        currentPage = Math.min(pageCount, currentPage + 1);
      } else {
        currentPage = parseInt(page);
      }
      
      renderMediaGrid();
      
      // Scroll to top of media grid
      mediaGrid.scrollIntoView({ behavior: 'smooth' });
    }
    
    // Show status message
    function showStatus(message, type) {
      statusMessage.textContent = message;
      statusMessage.className = 'status-message';
      statusMessage.classList.add(`status-${type}`);
      statusMessage.style.display = 'block';
      
      // Auto-hide after 3 seconds
      setTimeout(() => {
        statusMessage.style.display = 'none';
      }, 3000);
    }
  </script>
</body>
</html>